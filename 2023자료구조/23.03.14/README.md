# <center> **23년 3월 14일 자료구조 수업** </center>

# 배열과 벡터
> 배열?
 - 같은 종류의 데이터들이 일렬로 메모리에 저장되는 자료구조
 - 배열의 시작은 0부터 시작
 - 상수로 된 값으로만 배열 크기 설정 가능

> 배열의 초기화
 - int arr[ 8 ] = { 1 };
   - 첫번째 값에 1이 들어가고 나머지 0으로 들어간다
 - int arr[ 8 ] = { 1,  };
   - 첫번째 값에 1이 들어가고 나머지 0으로 들어간다
 - int arr[ 8 ] = { 0 };
   - 모두 0으로 들어간다
 - int arr[ 8 ] = { };
   - 모두 0으로 들어간다
 - int arr[ 8 ];
   - 모두 쓰레기값으로 들어간다

> 문자의 배열
 - char str[ ]  = { 'c', '+', '+' };
   - 사이즈 3
   - 마지막을 \0 (널)으로 널표시를 해주지 않으면 출력시 깨진 문자가 출력된다
 - char str[ ]  = "c++";
   - 사이즈 4
 - char str[ ]  = { "c++" };
   - 사이즈 4

> 포인터로서의 배열명
 - 배열의 이름은 배열의 0번째 인덱스의 주소를 나타낸다
   - int arr[ 2 ] = { 1, 2 };
   - int *p = arr;
   - 이때 *p, *arr는 같은 값을 가진다
 - 배열 선언시 배열의 이름은 상수주소를 가진다
   - 배열 변수에 다른 포인터를 담을 수 없다는 의미
   
> 2차원 배열
 - int s [ 3 ] [ 5 ]
   - 3행 5열짜리 2차원 배열
 - int s[ 3 ] [ 5 ] = {{0}}
 - int s[ 3 ] [ 5 ] = {{1}}

> fill 함수
 - enumerable 자료구조의 시작점부터 연속된 범위를 채우는 함수
 - void fill(ForwardIterator first, ForwardIterator last, const T& val);
 - first : 채우고자 하는 자료구조의 시작위치
 - iteratorlast : 채우고자 하는 자료구조의 끝 위치 last는 포함하지 않음
 - val : 채우고자 하는 값
 - 배열 초기화
   - int arr [ 3 ]
   - fill(arr, arr + 3);
 - 2차원 배열 초기화
   - int arr [ 3 ] [ 3 ]
   - fill(&a [ 0 ] [ 0 ], &a [ 2 ] [ 2 ] + 1, 0);

> 벡터?
 - 배열의 크기가 고정되어있다는 단점을 보안한 자료구조
 - vector<int> scores(10); 와 같이 선언
   - 크기를 꼭 설정해줄 필요는 없음
 - 늘리기는 가능하지만 늘리기 전 존재하지 않는 인덱스에 대입또는 호출이 불가능
   - vector<int> scores { 10, 20 };
   - scores [ 3 ] = 10;
   - 이거 불가능

> 벡터 초기화
 - vector<int> v1 { 10, 20 }; 이와 같이 초기화

> 벡터의 동작원리
 - 여유분을 두고 메모리를 할당
 - 여유분까지 꽉 찼으면 기존의 영역을 버리고 size의 1.5배 사이즈로 재정의
 - vector.capacity()
   - 여유분을 포함한 총 용량 개수
 - vector.size()
   - 실제 사용하고 있는 데이터 개수
 - capacity 는 늘긴 하지만 줄어들진 않음

> 벡터 복사 비용 줄이기
 - 필요한 사이즈를 안다면 reserve() 또는 resize() 를 이용하여 capacity를 설정
 - vector.reserve(10)
   - 여유분을 10만큼 만드는 함수
 - vector.resize(10)
   - 사이즈를 10만큼 설정하는 함수
   - push_back 시에 10번째 인덱스 부터 push 된다